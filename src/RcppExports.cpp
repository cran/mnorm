// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/mnorm.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// cmnorm
List cmnorm(const NumericVector mean, const NumericMatrix sigma, const NumericVector given_ind, const NumericVector given_x, NumericVector dependent_ind, const bool is_validation, const bool is_names, Nullable<List> control, const int n_cores);
static SEXP _mnorm_cmnorm_try(SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP given_xSEXP, SEXP dependent_indSEXP, SEXP is_validationSEXP, SEXP is_namesSEXP, SEXP controlSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_ind(given_indSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_x(given_xSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type dependent_ind(dependent_indSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_names(is_namesSEXP);
    Rcpp::traits::input_parameter< Nullable<List> >::type control(controlSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(cmnorm(mean, sigma, given_ind, given_x, dependent_ind, is_validation, is_names, control, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_cmnorm(SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP given_xSEXP, SEXP dependent_indSEXP, SEXP is_validationSEXP, SEXP is_namesSEXP, SEXP controlSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_cmnorm_try(meanSEXP, sigmaSEXP, given_indSEXP, given_xSEXP, dependent_indSEXP, is_validationSEXP, is_namesSEXP, controlSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dmnorm
List dmnorm(const NumericVector x, const NumericVector mean, const NumericMatrix sigma, const NumericVector given_ind, const bool log, const bool grad_x, const bool grad_sigma, const bool is_validation, const Nullable<List> control, const int n_cores);
static SEXP _mnorm_dmnorm_try(SEXP xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP logSEXP, SEXP grad_xSEXP, SEXP grad_sigmaSEXP, SEXP is_validationSEXP, SEXP controlSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type x(xSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_ind(given_indSEXP);
    Rcpp::traits::input_parameter< const bool >::type log(logSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_x(grad_xSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_sigma(grad_sigmaSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const Nullable<List> >::type control(controlSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(dmnorm(x, mean, sigma, given_ind, log, grad_x, grad_sigma, is_validation, control, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_dmnorm(SEXP xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP logSEXP, SEXP grad_xSEXP, SEXP grad_sigmaSEXP, SEXP is_validationSEXP, SEXP controlSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_dmnorm_try(xSEXP, meanSEXP, sigmaSEXP, given_indSEXP, logSEXP, grad_xSEXP, grad_sigmaSEXP, is_validationSEXP, controlSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// halton
NumericMatrix halton(const int n, const IntegerVector base, const int start, const String random, const String type, const bool is_validation, const int n_cores);
static SEXP _mnorm_halton_try(SEXP nSEXP, SEXP baseSEXP, SEXP startSEXP, SEXP randomSEXP, SEXP typeSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type n(nSEXP);
    Rcpp::traits::input_parameter< const IntegerVector >::type base(baseSEXP);
    Rcpp::traits::input_parameter< const int >::type start(startSEXP);
    Rcpp::traits::input_parameter< const String >::type random(randomSEXP);
    Rcpp::traits::input_parameter< const String >::type type(typeSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(halton(n, base, start, random, type, is_validation, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_halton(SEXP nSEXP, SEXP baseSEXP, SEXP startSEXP, SEXP randomSEXP, SEXP typeSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_mnorm_halton_try(nSEXP, baseSEXP, startSEXP, randomSEXP, typeSEXP, is_validationSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// haltonSingleDraw
double haltonSingleDraw(int ind, int base);
static SEXP _mnorm_haltonSingleDraw_try(SEXP indSEXP, SEXP baseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< int >::type ind(indSEXP);
    Rcpp::traits::input_parameter< int >::type base(baseSEXP);
    rcpp_result_gen = Rcpp::wrap(haltonSingleDraw(ind, base));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_haltonSingleDraw(SEXP indSEXP, SEXP baseSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_haltonSingleDraw_try(indSEXP, baseSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// seqPrimes
IntegerVector seqPrimes(const int n);
static SEXP _mnorm_seqPrimes_try(SEXP nSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type n(nSEXP);
    rcpp_result_gen = Rcpp::wrap(seqPrimes(n));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_seqPrimes(SEXP nSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_seqPrimes_try(nSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// pmnorm
List pmnorm(const NumericVector lower, const NumericVector upper, const NumericVector given_x, const NumericVector mean, const NumericMatrix sigma, const NumericVector given_ind, const int n_sim, const String method, const String ordering, const bool log, const bool grad_lower, const bool grad_upper, const bool grad_sigma, const bool grad_given, const bool is_validation, const Nullable<List> control, const int n_cores, const Nullable<List> marginal, const bool grad_marginal, const bool grad_marginal_prob);
static SEXP _mnorm_pmnorm_try(SEXP lowerSEXP, SEXP upperSEXP, SEXP given_xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP n_simSEXP, SEXP methodSEXP, SEXP orderingSEXP, SEXP logSEXP, SEXP grad_lowerSEXP, SEXP grad_upperSEXP, SEXP grad_sigmaSEXP, SEXP grad_givenSEXP, SEXP is_validationSEXP, SEXP controlSEXP, SEXP n_coresSEXP, SEXP marginalSEXP, SEXP grad_marginalSEXP, SEXP grad_marginal_probSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type lower(lowerSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type upper(upperSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_x(given_xSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_ind(given_indSEXP);
    Rcpp::traits::input_parameter< const int >::type n_sim(n_simSEXP);
    Rcpp::traits::input_parameter< const String >::type method(methodSEXP);
    Rcpp::traits::input_parameter< const String >::type ordering(orderingSEXP);
    Rcpp::traits::input_parameter< const bool >::type log(logSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_lower(grad_lowerSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_upper(grad_upperSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_sigma(grad_sigmaSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_given(grad_givenSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const Nullable<List> >::type control(controlSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    Rcpp::traits::input_parameter< const Nullable<List> >::type marginal(marginalSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_marginal(grad_marginalSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_marginal_prob(grad_marginal_probSEXP);
    rcpp_result_gen = Rcpp::wrap(pmnorm(lower, upper, given_x, mean, sigma, given_ind, n_sim, method, ordering, log, grad_lower, grad_upper, grad_sigma, grad_given, is_validation, control, n_cores, marginal, grad_marginal, grad_marginal_prob));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_pmnorm(SEXP lowerSEXP, SEXP upperSEXP, SEXP given_xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP n_simSEXP, SEXP methodSEXP, SEXP orderingSEXP, SEXP logSEXP, SEXP grad_lowerSEXP, SEXP grad_upperSEXP, SEXP grad_sigmaSEXP, SEXP grad_givenSEXP, SEXP is_validationSEXP, SEXP controlSEXP, SEXP n_coresSEXP, SEXP marginalSEXP, SEXP grad_marginalSEXP, SEXP grad_marginal_probSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_pmnorm_try(lowerSEXP, upperSEXP, given_xSEXP, meanSEXP, sigmaSEXP, given_indSEXP, n_simSEXP, methodSEXP, orderingSEXP, logSEXP, grad_lowerSEXP, grad_upperSEXP, grad_sigmaSEXP, grad_givenSEXP, is_validationSEXP, controlSEXP, n_coresSEXP, marginalSEXP, grad_marginalSEXP, grad_marginal_probSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// GHK
double GHK(const NumericVector lower, const NumericVector upper, const NumericMatrix sigma, const arma::mat h, const String ordering, const int n_sim, const int n_cores);
static SEXP _mnorm_GHK_try(SEXP lowerSEXP, SEXP upperSEXP, SEXP sigmaSEXP, SEXP hSEXP, SEXP orderingSEXP, SEXP n_simSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type lower(lowerSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type upper(upperSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type h(hSEXP);
    Rcpp::traits::input_parameter< const String >::type ordering(orderingSEXP);
    Rcpp::traits::input_parameter< const int >::type n_sim(n_simSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(GHK(lower, upper, sigma, h, ordering, n_sim, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_GHK(SEXP lowerSEXP, SEXP upperSEXP, SEXP sigmaSEXP, SEXP hSEXP, SEXP orderingSEXP, SEXP n_simSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_GHK_try(lowerSEXP, upperSEXP, sigmaSEXP, hSEXP, orderingSEXP, n_simSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// qnormFast
arma::vec qnormFast(arma::vec const& p, const int mean, const int sd, String method, bool is_validation, const int n_cores);
static SEXP _mnorm_qnormFast_try(SEXP pSEXP, SEXP meanSEXP, SEXP sdSEXP, SEXP methodSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::vec const& >::type p(pSEXP);
    Rcpp::traits::input_parameter< const int >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const int >::type sd(sdSEXP);
    Rcpp::traits::input_parameter< String >::type method(methodSEXP);
    Rcpp::traits::input_parameter< bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(qnormFast(p, mean, sd, method, is_validation, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_qnormFast(SEXP pSEXP, SEXP meanSEXP, SEXP sdSEXP, SEXP methodSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_qnormFast_try(pSEXP, meanSEXP, sdSEXP, methodSEXP, is_validationSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// rmnorm
NumericMatrix rmnorm(const int n, const NumericVector mean, const NumericMatrix sigma, const NumericVector given_ind, const NumericVector given_x, const NumericVector dependent_ind, const bool is_validation, const int n_cores);
static SEXP _mnorm_rmnorm_try(SEXP nSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP given_xSEXP, SEXP dependent_indSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type n(nSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_ind(given_indSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_x(given_xSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type dependent_ind(dependent_indSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(rmnorm(n, mean, sigma, given_ind, given_x, dependent_ind, is_validation, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_rmnorm(SEXP nSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP given_xSEXP, SEXP dependent_indSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_mnorm_rmnorm_try(nSEXP, meanSEXP, sigmaSEXP, given_indSEXP, given_xSEXP, dependent_indSEXP, is_validationSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _mnorm_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("List(*cmnorm)(const NumericVector,const NumericMatrix,const NumericVector,const NumericVector,NumericVector,const bool,const bool,Nullable<List>,const int)");
        signatures.insert("List(*dmnorm)(const NumericVector,const NumericVector,const NumericMatrix,const NumericVector,const bool,const bool,const bool,const bool,const Nullable<List>,const int)");
        signatures.insert("NumericMatrix(*halton)(const int,const IntegerVector,const int,const String,const String,const bool,const int)");
        signatures.insert("double(*haltonSingleDraw)(int,int)");
        signatures.insert("IntegerVector(*seqPrimes)(const int)");
        signatures.insert("List(*pmnorm)(const NumericVector,const NumericVector,const NumericVector,const NumericVector,const NumericMatrix,const NumericVector,const int,const String,const String,const bool,const bool,const bool,const bool,const bool,const bool,const Nullable<List>,const int,const Nullable<List>,const bool,const bool)");
        signatures.insert("double(*GHK)(const NumericVector,const NumericVector,const NumericMatrix,const arma::mat,const String,const int,const int)");
        signatures.insert("arma::vec(*qnormFast)(arma::vec const&,const int,const int,String,bool,const int)");
        signatures.insert("NumericMatrix(*rmnorm)(const int,const NumericVector,const NumericMatrix,const NumericVector,const NumericVector,const NumericVector,const bool,const int)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _mnorm_RcppExport_registerCCallable() { 
    R_RegisterCCallable("mnorm", "_mnorm_cmnorm", (DL_FUNC)_mnorm_cmnorm_try);
    R_RegisterCCallable("mnorm", "_mnorm_dmnorm", (DL_FUNC)_mnorm_dmnorm_try);
    R_RegisterCCallable("mnorm", "_mnorm_halton", (DL_FUNC)_mnorm_halton_try);
    R_RegisterCCallable("mnorm", "_mnorm_haltonSingleDraw", (DL_FUNC)_mnorm_haltonSingleDraw_try);
    R_RegisterCCallable("mnorm", "_mnorm_seqPrimes", (DL_FUNC)_mnorm_seqPrimes_try);
    R_RegisterCCallable("mnorm", "_mnorm_pmnorm", (DL_FUNC)_mnorm_pmnorm_try);
    R_RegisterCCallable("mnorm", "_mnorm_GHK", (DL_FUNC)_mnorm_GHK_try);
    R_RegisterCCallable("mnorm", "_mnorm_qnormFast", (DL_FUNC)_mnorm_qnormFast_try);
    R_RegisterCCallable("mnorm", "_mnorm_rmnorm", (DL_FUNC)_mnorm_rmnorm_try);
    R_RegisterCCallable("mnorm", "_mnorm_RcppExport_validate", (DL_FUNC)_mnorm_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_mnorm_cmnorm", (DL_FUNC) &_mnorm_cmnorm, 9},
    {"_mnorm_dmnorm", (DL_FUNC) &_mnorm_dmnorm, 10},
    {"_mnorm_halton", (DL_FUNC) &_mnorm_halton, 7},
    {"_mnorm_haltonSingleDraw", (DL_FUNC) &_mnorm_haltonSingleDraw, 2},
    {"_mnorm_seqPrimes", (DL_FUNC) &_mnorm_seqPrimes, 1},
    {"_mnorm_pmnorm", (DL_FUNC) &_mnorm_pmnorm, 20},
    {"_mnorm_GHK", (DL_FUNC) &_mnorm_GHK, 7},
    {"_mnorm_qnormFast", (DL_FUNC) &_mnorm_qnormFast, 6},
    {"_mnorm_rmnorm", (DL_FUNC) &_mnorm_rmnorm, 8},
    {"_mnorm_RcppExport_registerCCallable", (DL_FUNC) &_mnorm_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_mnorm(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
