// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/mnorm.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// cmnorm
List cmnorm(const NumericVector mean, const NumericMatrix sigma, const NumericVector given_ind, const NumericVector given_x, NumericVector dependent_ind, const bool is_validation, const bool is_names, Nullable<List> control, const int n_cores);
static SEXP _mnorm_cmnorm_try(SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP given_xSEXP, SEXP dependent_indSEXP, SEXP is_validationSEXP, SEXP is_namesSEXP, SEXP controlSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_ind(given_indSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_x(given_xSEXP);
    Rcpp::traits::input_parameter< NumericVector >::type dependent_ind(dependent_indSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_names(is_namesSEXP);
    Rcpp::traits::input_parameter< Nullable<List> >::type control(controlSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(cmnorm(mean, sigma, given_ind, given_x, dependent_ind, is_validation, is_names, control, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_cmnorm(SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP given_xSEXP, SEXP dependent_indSEXP, SEXP is_validationSEXP, SEXP is_namesSEXP, SEXP controlSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_cmnorm_try(meanSEXP, sigmaSEXP, given_indSEXP, given_xSEXP, dependent_indSEXP, is_validationSEXP, is_namesSEXP, controlSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dmnorm
List dmnorm(const NumericVector x, const NumericVector mean, const NumericMatrix sigma, const NumericVector given_ind, const bool log, const bool grad_x, const bool grad_sigma, const bool is_validation, const Nullable<List> control, const int n_cores);
static SEXP _mnorm_dmnorm_try(SEXP xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP logSEXP, SEXP grad_xSEXP, SEXP grad_sigmaSEXP, SEXP is_validationSEXP, SEXP controlSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type x(xSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_ind(given_indSEXP);
    Rcpp::traits::input_parameter< const bool >::type log(logSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_x(grad_xSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_sigma(grad_sigmaSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const Nullable<List> >::type control(controlSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(dmnorm(x, mean, sigma, given_ind, log, grad_x, grad_sigma, is_validation, control, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_dmnorm(SEXP xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP logSEXP, SEXP grad_xSEXP, SEXP grad_sigmaSEXP, SEXP is_validationSEXP, SEXP controlSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_dmnorm_try(xSEXP, meanSEXP, sigmaSEXP, given_indSEXP, logSEXP, grad_xSEXP, grad_sigmaSEXP, is_validationSEXP, controlSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// halton
NumericMatrix halton(const int n, const IntegerVector base, const int start, const String random, const String type, const String scrambler, const bool is_validation, const int n_cores);
static SEXP _mnorm_halton_try(SEXP nSEXP, SEXP baseSEXP, SEXP startSEXP, SEXP randomSEXP, SEXP typeSEXP, SEXP scramblerSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type n(nSEXP);
    Rcpp::traits::input_parameter< const IntegerVector >::type base(baseSEXP);
    Rcpp::traits::input_parameter< const int >::type start(startSEXP);
    Rcpp::traits::input_parameter< const String >::type random(randomSEXP);
    Rcpp::traits::input_parameter< const String >::type type(typeSEXP);
    Rcpp::traits::input_parameter< const String >::type scrambler(scramblerSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(halton(n, base, start, random, type, scrambler, is_validation, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_halton(SEXP nSEXP, SEXP baseSEXP, SEXP startSEXP, SEXP randomSEXP, SEXP typeSEXP, SEXP scramblerSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_mnorm_halton_try(nSEXP, baseSEXP, startSEXP, randomSEXP, typeSEXP, scramblerSEXP, is_validationSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// haltonSingleDraw
double haltonSingleDraw(int ind, int base, const String scrambler);
static SEXP _mnorm_haltonSingleDraw_try(SEXP indSEXP, SEXP baseSEXP, SEXP scramblerSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< int >::type ind(indSEXP);
    Rcpp::traits::input_parameter< int >::type base(baseSEXP);
    Rcpp::traits::input_parameter< const String >::type scrambler(scramblerSEXP);
    rcpp_result_gen = Rcpp::wrap(haltonSingleDraw(ind, base, scrambler));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_haltonSingleDraw(SEXP indSEXP, SEXP baseSEXP, SEXP scramblerSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_haltonSingleDraw_try(indSEXP, baseSEXP, scramblerSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// seqPrimes
IntegerVector seqPrimes(const int n);
static SEXP _mnorm_seqPrimes_try(SEXP nSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type n(nSEXP);
    rcpp_result_gen = Rcpp::wrap(seqPrimes(n));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_seqPrimes(SEXP nSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_seqPrimes_try(nSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// toBase
IntegerVector toBase(int x, const int base);
static SEXP _mnorm_toBase_try(SEXP xSEXP, SEXP baseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< int >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int >::type base(baseSEXP);
    rcpp_result_gen = Rcpp::wrap(toBase(x, base));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_toBase(SEXP xSEXP, SEXP baseSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_toBase_try(xSEXP, baseSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fromBase
double fromBase(const IntegerVector x, const int base);
static SEXP _mnorm_fromBase_try(SEXP xSEXP, SEXP baseSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const IntegerVector >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int >::type base(baseSEXP);
    rcpp_result_gen = Rcpp::wrap(fromBase(x, base));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_fromBase(SEXP xSEXP, SEXP baseSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_fromBase_try(xSEXP, baseSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// pmnorm
List pmnorm(const NumericVector lower, const NumericVector upper, const NumericVector given_x, const NumericVector mean, const NumericMatrix sigma, const NumericVector given_ind, const int n_sim, const String method, const String ordering, const bool log, const bool grad_lower, const bool grad_upper, const bool grad_sigma, const bool grad_given, const bool is_validation, const Nullable<List> control, const int n_cores, const Nullable<List> marginal, const bool grad_marginal, const bool grad_marginal_prob);
static SEXP _mnorm_pmnorm_try(SEXP lowerSEXP, SEXP upperSEXP, SEXP given_xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP n_simSEXP, SEXP methodSEXP, SEXP orderingSEXP, SEXP logSEXP, SEXP grad_lowerSEXP, SEXP grad_upperSEXP, SEXP grad_sigmaSEXP, SEXP grad_givenSEXP, SEXP is_validationSEXP, SEXP controlSEXP, SEXP n_coresSEXP, SEXP marginalSEXP, SEXP grad_marginalSEXP, SEXP grad_marginal_probSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type lower(lowerSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type upper(upperSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_x(given_xSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_ind(given_indSEXP);
    Rcpp::traits::input_parameter< const int >::type n_sim(n_simSEXP);
    Rcpp::traits::input_parameter< const String >::type method(methodSEXP);
    Rcpp::traits::input_parameter< const String >::type ordering(orderingSEXP);
    Rcpp::traits::input_parameter< const bool >::type log(logSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_lower(grad_lowerSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_upper(grad_upperSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_sigma(grad_sigmaSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_given(grad_givenSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const Nullable<List> >::type control(controlSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    Rcpp::traits::input_parameter< const Nullable<List> >::type marginal(marginalSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_marginal(grad_marginalSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_marginal_prob(grad_marginal_probSEXP);
    rcpp_result_gen = Rcpp::wrap(pmnorm(lower, upper, given_x, mean, sigma, given_ind, n_sim, method, ordering, log, grad_lower, grad_upper, grad_sigma, grad_given, is_validation, control, n_cores, marginal, grad_marginal, grad_marginal_prob));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_pmnorm(SEXP lowerSEXP, SEXP upperSEXP, SEXP given_xSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP n_simSEXP, SEXP methodSEXP, SEXP orderingSEXP, SEXP logSEXP, SEXP grad_lowerSEXP, SEXP grad_upperSEXP, SEXP grad_sigmaSEXP, SEXP grad_givenSEXP, SEXP is_validationSEXP, SEXP controlSEXP, SEXP n_coresSEXP, SEXP marginalSEXP, SEXP grad_marginalSEXP, SEXP grad_marginal_probSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_pmnorm_try(lowerSEXP, upperSEXP, given_xSEXP, meanSEXP, sigmaSEXP, given_indSEXP, n_simSEXP, methodSEXP, orderingSEXP, logSEXP, grad_lowerSEXP, grad_upperSEXP, grad_sigmaSEXP, grad_givenSEXP, is_validationSEXP, controlSEXP, n_coresSEXP, marginalSEXP, grad_marginalSEXP, grad_marginal_probSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// GHK
double GHK(const NumericVector lower, const NumericVector upper, const NumericMatrix sigma, const arma::mat h, const String ordering, const int n_sim, const int n_cores);
static SEXP _mnorm_GHK_try(SEXP lowerSEXP, SEXP upperSEXP, SEXP sigmaSEXP, SEXP hSEXP, SEXP orderingSEXP, SEXP n_simSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type lower(lowerSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type upper(upperSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type h(hSEXP);
    Rcpp::traits::input_parameter< const String >::type ordering(orderingSEXP);
    Rcpp::traits::input_parameter< const int >::type n_sim(n_simSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(GHK(lower, upper, sigma, h, ordering, n_sim, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_GHK(SEXP lowerSEXP, SEXP upperSEXP, SEXP sigmaSEXP, SEXP hSEXP, SEXP orderingSEXP, SEXP n_simSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_GHK_try(lowerSEXP, upperSEXP, sigmaSEXP, hSEXP, orderingSEXP, n_simSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// qnormFast
arma::vec qnormFast(arma::vec const& p, const int mean, const int sd, String method, bool is_validation, const int n_cores);
static SEXP _mnorm_qnormFast_try(SEXP pSEXP, SEXP meanSEXP, SEXP sdSEXP, SEXP methodSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::vec const& >::type p(pSEXP);
    Rcpp::traits::input_parameter< const int >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const int >::type sd(sdSEXP);
    Rcpp::traits::input_parameter< String >::type method(methodSEXP);
    Rcpp::traits::input_parameter< bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(qnormFast(p, mean, sd, method, is_validation, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_qnormFast(SEXP pSEXP, SEXP meanSEXP, SEXP sdSEXP, SEXP methodSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_qnormFast_try(pSEXP, meanSEXP, sdSEXP, methodSEXP, is_validationSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// rmnorm
NumericMatrix rmnorm(const int n, const NumericVector mean, const NumericMatrix sigma, const NumericVector given_ind, const NumericVector given_x, const NumericVector dependent_ind, const bool is_validation, const int n_cores);
static SEXP _mnorm_rmnorm_try(SEXP nSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP given_xSEXP, SEXP dependent_indSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type n(nSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type mean(meanSEXP);
    Rcpp::traits::input_parameter< const NumericMatrix >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_ind(given_indSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type given_x(given_xSEXP);
    Rcpp::traits::input_parameter< const NumericVector >::type dependent_ind(dependent_indSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const int >::type n_cores(n_coresSEXP);
    rcpp_result_gen = Rcpp::wrap(rmnorm(n, mean, sigma, given_ind, given_x, dependent_ind, is_validation, n_cores));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_rmnorm(SEXP nSEXP, SEXP meanSEXP, SEXP sigmaSEXP, SEXP given_indSEXP, SEXP given_xSEXP, SEXP dependent_indSEXP, SEXP is_validationSEXP, SEXP n_coresSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_mnorm_rmnorm_try(nSEXP, meanSEXP, sigmaSEXP, given_indSEXP, given_xSEXP, dependent_indSEXP, is_validationSEXP, n_coresSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// pbetaDiff
List pbetaDiff(const arma::vec x, const double p, const double q, const int n, const bool is_validation, const Nullable<List> control);
static SEXP _mnorm_pbetaDiff_try(SEXP xSEXP, SEXP pSEXP, SEXP qSEXP, SEXP nSEXP, SEXP is_validationSEXP, SEXP controlSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< const double >::type p(pSEXP);
    Rcpp::traits::input_parameter< const double >::type q(qSEXP);
    Rcpp::traits::input_parameter< const int >::type n(nSEXP);
    Rcpp::traits::input_parameter< const bool >::type is_validation(is_validationSEXP);
    Rcpp::traits::input_parameter< const Nullable<List> >::type control(controlSEXP);
    rcpp_result_gen = Rcpp::wrap(pbetaDiff(x, p, q, n, is_validation, control));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_pbetaDiff(SEXP xSEXP, SEXP pSEXP, SEXP qSEXP, SEXP nSEXP, SEXP is_validationSEXP, SEXP controlSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_pbetaDiff_try(xSEXP, pSEXP, qSEXP, nSEXP, is_validationSEXP, controlSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dt0
List dt0(const arma::vec x, const double df, const bool log, const bool grad_x, const bool grad_df);
static SEXP _mnorm_dt0_try(SEXP xSEXP, SEXP dfSEXP, SEXP logSEXP, SEXP grad_xSEXP, SEXP grad_dfSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< const double >::type df(dfSEXP);
    Rcpp::traits::input_parameter< const bool >::type log(logSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_x(grad_xSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_df(grad_dfSEXP);
    rcpp_result_gen = Rcpp::wrap(dt0(x, df, log, grad_x, grad_df));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_dt0(SEXP xSEXP, SEXP dfSEXP, SEXP logSEXP, SEXP grad_xSEXP, SEXP grad_dfSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_dt0_try(xSEXP, dfSEXP, logSEXP, grad_xSEXP, grad_dfSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// pt0
List pt0(const arma::vec x, const double df, const bool log, const bool grad_x, const bool grad_df, const int n);
static SEXP _mnorm_pt0_try(SEXP xSEXP, SEXP dfSEXP, SEXP logSEXP, SEXP grad_xSEXP, SEXP grad_dfSEXP, SEXP nSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< const double >::type df(dfSEXP);
    Rcpp::traits::input_parameter< const bool >::type log(logSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_x(grad_xSEXP);
    Rcpp::traits::input_parameter< const bool >::type grad_df(grad_dfSEXP);
    Rcpp::traits::input_parameter< const int >::type n(nSEXP);
    rcpp_result_gen = Rcpp::wrap(pt0(x, df, log, grad_x, grad_df, n));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_pt0(SEXP xSEXP, SEXP dfSEXP, SEXP logSEXP, SEXP grad_xSEXP, SEXP grad_dfSEXP, SEXP nSEXP) {
    SEXP rcpp_result_gen;
    {
        rcpp_result_gen = PROTECT(_mnorm_pt0_try(xSEXP, dfSEXP, logSEXP, grad_xSEXP, grad_dfSEXP, nSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// rt0
NumericVector rt0(const int n, const double df);
static SEXP _mnorm_rt0_try(SEXP nSEXP, SEXP dfSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type n(nSEXP);
    Rcpp::traits::input_parameter< const double >::type df(dfSEXP);
    rcpp_result_gen = Rcpp::wrap(rt0(n, df));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_rt0(SEXP nSEXP, SEXP dfSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_mnorm_rt0_try(nSEXP, dfSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// qt0
NumericVector qt0(const NumericVector x, const double df);
static SEXP _mnorm_qt0_try(SEXP xSEXP, SEXP dfSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const NumericVector >::type x(xSEXP);
    Rcpp::traits::input_parameter< const double >::type df(dfSEXP);
    rcpp_result_gen = Rcpp::wrap(qt0(x, df));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _mnorm_qt0(SEXP xSEXP, SEXP dfSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_mnorm_qt0_try(xSEXP, dfSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error("%s", CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _mnorm_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("List(*cmnorm)(const NumericVector,const NumericMatrix,const NumericVector,const NumericVector,NumericVector,const bool,const bool,Nullable<List>,const int)");
        signatures.insert("List(*dmnorm)(const NumericVector,const NumericVector,const NumericMatrix,const NumericVector,const bool,const bool,const bool,const bool,const Nullable<List>,const int)");
        signatures.insert("NumericMatrix(*halton)(const int,const IntegerVector,const int,const String,const String,const String,const bool,const int)");
        signatures.insert("double(*haltonSingleDraw)(int,int,const String)");
        signatures.insert("IntegerVector(*seqPrimes)(const int)");
        signatures.insert("IntegerVector(*toBase)(int,const int)");
        signatures.insert("double(*fromBase)(const IntegerVector,const int)");
        signatures.insert("List(*pmnorm)(const NumericVector,const NumericVector,const NumericVector,const NumericVector,const NumericMatrix,const NumericVector,const int,const String,const String,const bool,const bool,const bool,const bool,const bool,const bool,const Nullable<List>,const int,const Nullable<List>,const bool,const bool)");
        signatures.insert("double(*GHK)(const NumericVector,const NumericVector,const NumericMatrix,const arma::mat,const String,const int,const int)");
        signatures.insert("arma::vec(*qnormFast)(arma::vec const&,const int,const int,String,bool,const int)");
        signatures.insert("NumericMatrix(*rmnorm)(const int,const NumericVector,const NumericMatrix,const NumericVector,const NumericVector,const NumericVector,const bool,const int)");
        signatures.insert("List(*pbetaDiff)(const arma::vec,const double,const double,const int,const bool,const Nullable<List>)");
        signatures.insert("List(*dt0)(const arma::vec,const double,const bool,const bool,const bool)");
        signatures.insert("List(*pt0)(const arma::vec,const double,const bool,const bool,const bool,const int)");
        signatures.insert("NumericVector(*rt0)(const int,const double)");
        signatures.insert("NumericVector(*qt0)(const NumericVector,const double)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _mnorm_RcppExport_registerCCallable() { 
    R_RegisterCCallable("mnorm", "_mnorm_cmnorm", (DL_FUNC)_mnorm_cmnorm_try);
    R_RegisterCCallable("mnorm", "_mnorm_dmnorm", (DL_FUNC)_mnorm_dmnorm_try);
    R_RegisterCCallable("mnorm", "_mnorm_halton", (DL_FUNC)_mnorm_halton_try);
    R_RegisterCCallable("mnorm", "_mnorm_haltonSingleDraw", (DL_FUNC)_mnorm_haltonSingleDraw_try);
    R_RegisterCCallable("mnorm", "_mnorm_seqPrimes", (DL_FUNC)_mnorm_seqPrimes_try);
    R_RegisterCCallable("mnorm", "_mnorm_toBase", (DL_FUNC)_mnorm_toBase_try);
    R_RegisterCCallable("mnorm", "_mnorm_fromBase", (DL_FUNC)_mnorm_fromBase_try);
    R_RegisterCCallable("mnorm", "_mnorm_pmnorm", (DL_FUNC)_mnorm_pmnorm_try);
    R_RegisterCCallable("mnorm", "_mnorm_GHK", (DL_FUNC)_mnorm_GHK_try);
    R_RegisterCCallable("mnorm", "_mnorm_qnormFast", (DL_FUNC)_mnorm_qnormFast_try);
    R_RegisterCCallable("mnorm", "_mnorm_rmnorm", (DL_FUNC)_mnorm_rmnorm_try);
    R_RegisterCCallable("mnorm", "_mnorm_pbetaDiff", (DL_FUNC)_mnorm_pbetaDiff_try);
    R_RegisterCCallable("mnorm", "_mnorm_dt0", (DL_FUNC)_mnorm_dt0_try);
    R_RegisterCCallable("mnorm", "_mnorm_pt0", (DL_FUNC)_mnorm_pt0_try);
    R_RegisterCCallable("mnorm", "_mnorm_rt0", (DL_FUNC)_mnorm_rt0_try);
    R_RegisterCCallable("mnorm", "_mnorm_qt0", (DL_FUNC)_mnorm_qt0_try);
    R_RegisterCCallable("mnorm", "_mnorm_RcppExport_validate", (DL_FUNC)_mnorm_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_mnorm_cmnorm", (DL_FUNC) &_mnorm_cmnorm, 9},
    {"_mnorm_dmnorm", (DL_FUNC) &_mnorm_dmnorm, 10},
    {"_mnorm_halton", (DL_FUNC) &_mnorm_halton, 8},
    {"_mnorm_haltonSingleDraw", (DL_FUNC) &_mnorm_haltonSingleDraw, 3},
    {"_mnorm_seqPrimes", (DL_FUNC) &_mnorm_seqPrimes, 1},
    {"_mnorm_toBase", (DL_FUNC) &_mnorm_toBase, 2},
    {"_mnorm_fromBase", (DL_FUNC) &_mnorm_fromBase, 2},
    {"_mnorm_pmnorm", (DL_FUNC) &_mnorm_pmnorm, 20},
    {"_mnorm_GHK", (DL_FUNC) &_mnorm_GHK, 7},
    {"_mnorm_qnormFast", (DL_FUNC) &_mnorm_qnormFast, 6},
    {"_mnorm_rmnorm", (DL_FUNC) &_mnorm_rmnorm, 8},
    {"_mnorm_pbetaDiff", (DL_FUNC) &_mnorm_pbetaDiff, 6},
    {"_mnorm_dt0", (DL_FUNC) &_mnorm_dt0, 5},
    {"_mnorm_pt0", (DL_FUNC) &_mnorm_pt0, 6},
    {"_mnorm_rt0", (DL_FUNC) &_mnorm_rt0, 2},
    {"_mnorm_qt0", (DL_FUNC) &_mnorm_qt0, 2},
    {"_mnorm_RcppExport_registerCCallable", (DL_FUNC) &_mnorm_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_mnorm(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
